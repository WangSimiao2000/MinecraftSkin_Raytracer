/**
 * Property-based tests for MeshBuilder.
 *
 * **Validates: Requirements 2.1, 2.3**
 *
 * Property 4: Mesh Generation Completeness (网格生成完整性)
 * For any valid SkinData, each inner-layer mesh generated by MeshBuilder
 * should contain exactly 12 triangles (6 faces × 2 triangles), and every
 * triangle's UV coordinates should be in the [0, 1] range.
 */

#include <gtest/gtest.h>
#include <rapidcheck.h>
#include <rapidcheck/gtest.h>

#include "skin/skin_parser.h"
#include "skin/texture_region.h"
#include "scene/mesh_builder.h"
#include "scene/scene.h"
#include "math/color.h"

// ── Helpers ─────────────────────────────────────────────────────────────────

// Generate a random TextureRegion with non-zero alpha pixels.
// w = width, h = height of the face texture.
static TextureRegion generateOpaqueRegion(int w, int h) {
    TextureRegion region(w, h);
    for (int i = 0; i < w * h; ++i) {
        float r = *rc::gen::inRange(0, 256) / 255.0f;
        float g = *rc::gen::inRange(0, 256) / 255.0f;
        float b = *rc::gen::inRange(0, 256) / 255.0f;
        // Alpha in [1, 255] to ensure non-transparent
        float a = *rc::gen::inRange(1, 256) / 255.0f;
        region.pixels[i] = Color(r, g, b, a);
    }
    return region;
}

// Generate a BodyPartTexture for a box with dimensions (w, h, d).
// Face dimensions follow Minecraft skin layout:
//   top/bottom: w × d
//   front/back: w × h
//   left/right: d × h
static BodyPartTexture generateBodyPartTexture(int w, int h, int d) {
    BodyPartTexture tex;
    tex.top    = generateOpaqueRegion(w, d);
    tex.bottom = generateOpaqueRegion(w, d);
    tex.front  = generateOpaqueRegion(w, h);
    tex.back   = generateOpaqueRegion(w, h);
    tex.left   = generateOpaqueRegion(d, h);
    tex.right  = generateOpaqueRegion(d, h);
    return tex;
}

// Generate a fully transparent BodyPartTexture (alpha = 0 for all pixels).
static BodyPartTexture generateTransparentBodyPartTexture(int w, int h, int d) {
    BodyPartTexture tex;
    auto makeTransparent = [](int tw, int th) {
        TextureRegion region(tw, th);
        for (int i = 0; i < tw * th; ++i) {
            region.pixels[i] = Color(0.0f, 0.0f, 0.0f, 0.0f);
        }
        return region;
    };
    tex.top    = makeTransparent(w, d);
    tex.bottom = makeTransparent(w, d);
    tex.front  = makeTransparent(w, h);
    tex.back   = makeTransparent(w, h);
    tex.left   = makeTransparent(d, h);
    tex.right  = makeTransparent(d, h);
    return tex;
}

// Build a random valid SkinData with NEW_64x64 format.
// Inner layers always have opaque pixels.
// Outer layers are randomly either opaque or fully transparent.
static SkinData generateRandomSkinData() {
    SkinData skin;
    skin.format = SkinData::NEW_64x64;

    // Body part dimensions: {w, h, d}
    // Head: 8×8×8, Body: 8×12×4, Arms: 4×12×4, Legs: 4×12×4
    struct PartDims { int w, h, d; };
    PartDims dims[] = {
        {8, 8, 8},   // head
        {8, 12, 4},  // body
        {4, 12, 4},  // rightArm
        {4, 12, 4},  // leftArm
        {4, 12, 4},  // rightLeg
        {4, 12, 4},  // leftLeg
    };

    // Inner layers (always opaque)
    skin.head     = generateBodyPartTexture(dims[0].w, dims[0].h, dims[0].d);
    skin.body     = generateBodyPartTexture(dims[1].w, dims[1].h, dims[1].d);
    skin.rightArm = generateBodyPartTexture(dims[2].w, dims[2].h, dims[2].d);
    skin.leftArm  = generateBodyPartTexture(dims[3].w, dims[3].h, dims[3].d);
    skin.rightLeg = generateBodyPartTexture(dims[4].w, dims[4].h, dims[4].d);
    skin.leftLeg  = generateBodyPartTexture(dims[5].w, dims[5].h, dims[5].d);

    // Outer layers: randomly opaque or transparent
    auto genOuter = [](int w, int h, int d) -> BodyPartTexture {
        bool transparent = *rc::gen::inRange(0, 2) == 0;
        if (transparent) {
            return generateTransparentBodyPartTexture(w, h, d);
        }
        return generateBodyPartTexture(w, h, d);
    };

    skin.headOuter     = genOuter(dims[0].w, dims[0].h, dims[0].d);
    skin.bodyOuter     = genOuter(dims[1].w, dims[1].h, dims[1].d);
    skin.rightArmOuter = genOuter(dims[2].w, dims[2].h, dims[2].d);
    skin.leftArmOuter  = genOuter(dims[3].w, dims[3].h, dims[3].d);
    skin.rightLegOuter = genOuter(dims[4].w, dims[4].h, dims[4].d);
    skin.leftLegOuter  = genOuter(dims[5].w, dims[5].h, dims[5].d);

    return skin;
}

// ── Property 4: Mesh Generation Completeness ────────────────────────────────
//
// **Validates: Requirements 2.1, 2.3**
//
// For any valid SkinData, MeshBuilder::buildScene should produce:
// 1. Each inner-layer mesh has exactly 12 triangles (6 faces × 2 triangles)
// 2. Each triangle's UV coordinates are in [0, 1]
// 3. The scene has 6 inner meshes + up to 6 outer meshes

RC_GTEST_PROP(MeshBuilderProps, MeshGenerationCompleteness, ()) {
    SkinData skin = generateRandomSkinData();
    Scene scene = MeshBuilder::buildScene(skin);

    // Count inner and outer meshes
    int innerCount = 0;
    int outerCount = 0;
    for (const auto& mesh : scene.meshes) {
        if (mesh.isOuterLayer) {
            outerCount++;
        } else {
            innerCount++;
        }
    }

    // Must have exactly 6 inner-layer meshes (one per body part)
    RC_ASSERT(innerCount == 6);

    // Outer count should be between 0 and 6
    RC_ASSERT(outerCount >= 0);
    RC_ASSERT(outerCount <= 6);

    // Total meshes = inner + outer
    RC_ASSERT(static_cast<int>(scene.meshes.size()) == innerCount + outerCount);

    // Verify each inner-layer mesh
    for (const auto& mesh : scene.meshes) {
        if (mesh.isOuterLayer) continue;

        // Each inner mesh must have exactly 12 triangles (6 faces × 2)
        RC_ASSERT(static_cast<int>(mesh.triangles.size()) == 12);

        // Each triangle's UV coordinates must be in [0, 1]
        for (const auto& tri : mesh.triangles) {
            RC_ASSERT(tri.u0 >= 0.0f && tri.u0 <= 1.0f);
            RC_ASSERT(tri.v0_uv >= 0.0f && tri.v0_uv <= 1.0f);
            RC_ASSERT(tri.u1 >= 0.0f && tri.u1 <= 1.0f);
            RC_ASSERT(tri.v1_uv >= 0.0f && tri.v1_uv <= 1.0f);
            RC_ASSERT(tri.u2 >= 0.0f && tri.u2 <= 1.0f);
            RC_ASSERT(tri.v2_uv >= 0.0f && tri.v2_uv <= 1.0f);
        }
    }

    // Also verify outer-layer meshes have 12 triangles and valid UVs
    for (const auto& mesh : scene.meshes) {
        if (!mesh.isOuterLayer) continue;

        RC_ASSERT(static_cast<int>(mesh.triangles.size()) == 12);

        for (const auto& tri : mesh.triangles) {
            RC_ASSERT(tri.u0 >= 0.0f && tri.u0 <= 1.0f);
            RC_ASSERT(tri.v0_uv >= 0.0f && tri.v0_uv <= 1.0f);
            RC_ASSERT(tri.u1 >= 0.0f && tri.u1 <= 1.0f);
            RC_ASSERT(tri.v1_uv >= 0.0f && tri.v1_uv <= 1.0f);
            RC_ASSERT(tri.u2 >= 0.0f && tri.u2 <= 1.0f);
            RC_ASSERT(tri.v2_uv >= 0.0f && tri.v2_uv <= 1.0f);
        }
    }
}

// ── Helpers for Property 5 ──────────────────────────────────────────────────

// Generate a random valid SkinData where ALL outer layers are opaque (non-transparent).
// This guarantees buildScene produces exactly 12 meshes: 6 inner + 6 outer,
// in alternating order (inner0, outer0, inner1, outer1, ...).
static SkinData generateSkinDataAllOutersOpaque() {
    SkinData skin;
    skin.format = SkinData::NEW_64x64;

    struct PartDims { int w, h, d; };
    PartDims dims[] = {
        {8, 8, 8},   // head
        {8, 12, 4},  // body
        {4, 12, 4},  // rightArm
        {4, 12, 4},  // leftArm
        {4, 12, 4},  // rightLeg
        {4, 12, 4},  // leftLeg
    };

    // Inner layers (always opaque)
    skin.head     = generateBodyPartTexture(dims[0].w, dims[0].h, dims[0].d);
    skin.body     = generateBodyPartTexture(dims[1].w, dims[1].h, dims[1].d);
    skin.rightArm = generateBodyPartTexture(dims[2].w, dims[2].h, dims[2].d);
    skin.leftArm  = generateBodyPartTexture(dims[3].w, dims[3].h, dims[3].d);
    skin.rightLeg = generateBodyPartTexture(dims[4].w, dims[4].h, dims[4].d);
    skin.leftLeg  = generateBodyPartTexture(dims[5].w, dims[5].h, dims[5].d);

    // Outer layers: ALL opaque (non-transparent)
    skin.headOuter     = generateBodyPartTexture(dims[0].w, dims[0].h, dims[0].d);
    skin.bodyOuter     = generateBodyPartTexture(dims[1].w, dims[1].h, dims[1].d);
    skin.rightArmOuter = generateBodyPartTexture(dims[2].w, dims[2].h, dims[2].d);
    skin.leftArmOuter  = generateBodyPartTexture(dims[3].w, dims[3].h, dims[3].d);
    skin.rightLegOuter = generateBodyPartTexture(dims[4].w, dims[4].h, dims[4].d);
    skin.leftLegOuter  = generateBodyPartTexture(dims[5].w, dims[5].h, dims[5].d);

    return skin;
}

// Axis-aligned bounding box
struct AABB {
    Vec3 min;
    Vec3 max;
};

// Compute the bounding box of a mesh from all triangle vertices.
static AABB computeBoundingBox(const Mesh& mesh) {
    AABB box;
    box.min = Vec3( 1e30f,  1e30f,  1e30f);
    box.max = Vec3(-1e30f, -1e30f, -1e30f);

    for (const auto& tri : mesh.triangles) {
        const Vec3* verts[] = { &tri.v0, &tri.v1, &tri.v2 };
        for (const Vec3* v : verts) {
            if (v->x < box.min.x) box.min.x = v->x;
            if (v->y < box.min.y) box.min.y = v->y;
            if (v->z < box.min.z) box.min.z = v->z;
            if (v->x > box.max.x) box.max.x = v->x;
            if (v->y > box.max.y) box.max.y = v->y;
            if (v->z > box.max.z) box.max.z = v->z;
        }
    }
    return box;
}

// ── Property 5: Outer Mesh Expansion (外层网格扩展) ─────────────────────────
//
// **Validates: Requirements 2.2**
//
// For any valid SkinData where all outer textures are non-transparent,
// the outer mesh bounding box should be exactly 2 × offset (= 1.0) larger
// than the inner mesh bounding box in each axis direction (0.5 on each side).

RC_GTEST_PROP(MeshBuilderProps, OuterMeshExpansion, ()) {
    constexpr float OFFSET = 0.5f;
    constexpr float EXPECTED_EXPANSION = 2.0f * OFFSET;  // 1.0
    constexpr float TOLERANCE = 1e-4f;

    SkinData skin = generateSkinDataAllOutersOpaque();
    Scene scene = MeshBuilder::buildScene(skin);

    // With all outer layers opaque, we expect exactly 12 meshes:
    // inner0, outer0, inner1, outer1, ..., inner5, outer5
    RC_ASSERT(scene.meshes.size() == 12u);

    // For each body part (6 parts), pair inner (even index) with outer (odd index)
    for (int i = 0; i < 6; ++i) {
        const Mesh& innerMesh = scene.meshes[i * 2];
        const Mesh& outerMesh = scene.meshes[i * 2 + 1];

        RC_ASSERT(!innerMesh.isOuterLayer);
        RC_ASSERT(outerMesh.isOuterLayer);

        AABB innerBox = computeBoundingBox(innerMesh);
        AABB outerBox = computeBoundingBox(outerMesh);

        // Outer bounding box extent in each axis should be larger by EXPECTED_EXPANSION
        float innerExtentX = innerBox.max.x - innerBox.min.x;
        float innerExtentY = innerBox.max.y - innerBox.min.y;
        float innerExtentZ = innerBox.max.z - innerBox.min.z;

        float outerExtentX = outerBox.max.x - outerBox.min.x;
        float outerExtentY = outerBox.max.y - outerBox.min.y;
        float outerExtentZ = outerBox.max.z - outerBox.min.z;

        RC_ASSERT(std::abs((outerExtentX - innerExtentX) - EXPECTED_EXPANSION) < TOLERANCE);
        RC_ASSERT(std::abs((outerExtentY - innerExtentY) - EXPECTED_EXPANSION) < TOLERANCE);
        RC_ASSERT(std::abs((outerExtentZ - innerExtentZ) - EXPECTED_EXPANSION) < TOLERANCE);

        // Also verify each side expands by exactly OFFSET
        RC_ASSERT(std::abs((innerBox.min.x - outerBox.min.x) - OFFSET) < TOLERANCE);
        RC_ASSERT(std::abs((outerBox.max.x - innerBox.max.x) - OFFSET) < TOLERANCE);
        RC_ASSERT(std::abs((innerBox.min.y - outerBox.min.y) - OFFSET) < TOLERANCE);
        RC_ASSERT(std::abs((outerBox.max.y - innerBox.max.y) - OFFSET) < TOLERANCE);
        RC_ASSERT(std::abs((innerBox.min.z - outerBox.min.z) - OFFSET) < TOLERANCE);
        RC_ASSERT(std::abs((outerBox.max.z - innerBox.max.z) - OFFSET) < TOLERANCE);
    }
}

// ── Helpers for Property 6 ──────────────────────────────────────────────────

// Generate a random valid SkinData where ALL outer layers are fully transparent.
// This guarantees buildScene should produce exactly 6 meshes (inner only).
static SkinData generateSkinDataAllOutersTransparent() {
    SkinData skin;
    skin.format = SkinData::NEW_64x64;

    struct PartDims { int w, h, d; };
    PartDims dims[] = {
        {8, 8, 8},   // head
        {8, 12, 4},  // body
        {4, 12, 4},  // rightArm
        {4, 12, 4},  // leftArm
        {4, 12, 4},  // rightLeg
        {4, 12, 4},  // leftLeg
    };

    // Inner layers (always opaque)
    skin.head     = generateBodyPartTexture(dims[0].w, dims[0].h, dims[0].d);
    skin.body     = generateBodyPartTexture(dims[1].w, dims[1].h, dims[1].d);
    skin.rightArm = generateBodyPartTexture(dims[2].w, dims[2].h, dims[2].d);
    skin.leftArm  = generateBodyPartTexture(dims[3].w, dims[3].h, dims[3].d);
    skin.rightLeg = generateBodyPartTexture(dims[4].w, dims[4].h, dims[4].d);
    skin.leftLeg  = generateBodyPartTexture(dims[5].w, dims[5].h, dims[5].d);

    // Outer layers: ALL fully transparent (alpha = 0)
    skin.headOuter     = generateTransparentBodyPartTexture(dims[0].w, dims[0].h, dims[0].d);
    skin.bodyOuter     = generateTransparentBodyPartTexture(dims[1].w, dims[1].h, dims[1].d);
    skin.rightArmOuter = generateTransparentBodyPartTexture(dims[2].w, dims[2].h, dims[2].d);
    skin.leftArmOuter  = generateTransparentBodyPartTexture(dims[3].w, dims[3].h, dims[3].d);
    skin.rightLegOuter = generateTransparentBodyPartTexture(dims[4].w, dims[4].h, dims[4].d);
    skin.leftLegOuter  = generateTransparentBodyPartTexture(dims[5].w, dims[5].h, dims[5].d);

    return skin;
}

// ── Property 6: Fully Transparent Outer Layer Skip (全透明外层跳过) ──────────
//
// **Validates: Requirements 2.5**
//
// For any valid SkinData where ALL outer layer textures have alpha = 0 for
// every pixel, MeshBuilder::buildScene should NOT generate any outer layer
// meshes. The scene should contain exactly 6 meshes (inner layers only),
// and none of them should have isOuterLayer = true.

RC_GTEST_PROP(MeshBuilderProps, FullyTransparentOuterLayerSkip, ()) {
    SkinData skin = generateSkinDataAllOutersTransparent();
    Scene scene = MeshBuilder::buildScene(skin);

    // Must have exactly 6 meshes (one inner per body part, no outer)
    RC_ASSERT(scene.meshes.size() == 6u);

    // None of the meshes should be outer layer
    for (const auto& mesh : scene.meshes) {
        RC_ASSERT(!mesh.isOuterLayer);
    }
}
